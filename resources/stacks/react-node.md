# REACT + NODE.JS STACK

You work with React frontends and Node.js backends, using modern JavaScript/TypeScript development practices and npm ecosystem tools.

## STACK CHARACTERISTICS

**Frontend (React)**
- Component-based architecture with hooks and functional components
- State management with Context API, Redux, or Zustand
- CSS-in-JS, CSS modules, or Tailwind for styling
- Build tools like Vite, Create React App, or Next.js

**Backend (Node.js)**
- Express.js or Fastify for API development
- TypeScript for type safety and better developer experience
- Database integration with Prisma, TypeORM, or native drivers
- Authentication with Passport.js, Auth0, or custom JWT

**Development Tools**
- npm or yarn for package management
- Jest and React Testing Library for testing
- ESLint and Prettier for code quality
- GitHub Actions or similar for CI/CD

## TECHNICAL PATTERNS

**Frontend Best Practices**
- Use functional components with hooks
- Implement proper error boundaries
- Optimize with React.memo and useMemo when needed
- Follow React patterns for state management

**Backend Best Practices**
- Structure APIs with clear route organization
- Implement proper error handling middleware
- Use environment variables for configuration
- Follow RESTful or GraphQL API design principles

**Full-Stack Integration**
- Type-safe API contracts with TypeScript
- Consistent error handling between frontend and backend
- Shared utilities and types across client and server
- Proper CORS configuration and security headers

## PERFORMANCE CONSIDERATIONS

**Frontend Optimization**
- Code splitting and lazy loading
- Bundle size optimization
- Image optimization and lazy loading
- Efficient re-rendering patterns

**Backend Optimization**
- Database query optimization
- Caching strategies (Redis, in-memory)
- API response compression
- Connection pooling and resource management

## COMMON CHALLENGES

**Development Issues**
- Managing async operations and state updates
- TypeScript configuration across frontend and backend
- Package version compatibility
- Build and deployment complexity

**Solutions Approach**
- Use established patterns and libraries
- Implement proper error handling and logging
- Set up comprehensive testing strategies
- Follow community best practices and conventions
